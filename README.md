# Докеризация Python/Django приложения

## Цель лабораторной работы
Создать и запустить в Docker контейнере работоспособное Python/Django приложение с базой данных PostgreSQL, выполнив указанные требования.

---

## Условия для выполнения лабораторной работы

1. Образ должен быть легковесным.
2. Использовать базовые легковесные образы - Alpine.
3. Вся конфигурация приложения должна быть через переменные окружения.
4. Статика и зависимости должны быть вынесены во внешние тома `volume`.
5. Создать файл `docker-compose.yml` для старта и сборки приложения.
6. В `docker-compose.yml` нужно подключить базу данных.
7. При старте приложения должны автоматически выполняться миграции.
8. Контейнер приложения должен запускаться от непривилегированного пользователя.
9. После установки всех необходимых утилит должен очищаться кэш.

---

## Реализация лабораторной работы

### 1. Выбор приложения
В качестве приложения для выполнения лабораторной работы было выбрано приложение online-store, с помощью которого можно создавать карточки товаров. 

### 2. Dockerfile
Для приложения был создан следующий `Dockerfile`:

```dockerfile
# Используем базовый образ Python на основе Alpine - легковесной дистрибутивы Linux, которая делает образ меньше и быстрее.
FROM python:3.12-alpine

# Устанавливаем переменные окружения
ENV PYTHONUNBUFFERED=1 # Это гарантирует, что вывод будет отправляться сразу, а не буферизироваться.
ENV PYTHONDONTWRITEBYTECODE=1 # Это предотвращает создание файлов байт-кода Python в контейнере.

# Обновляем пакеты 
RUN apk --update add

# Устанавливаем рабочую директорию внутри контейнера. Все последующие команды будут выполняться в этой директории.
WORKDIR /var/backend

# Копируем все файлы из текущей директории на хосте в рабочую директорию.
COPY . .

# Обновляем pip.
RUN pip install --upgrade pip

# Устанавливаем зависимости из файла requirements.txt.
RUN pip install --no-cache-dir -r requirements.txt #  Это предотвращает сохранение кэша pip, что уменьшает размер образа.

# Создаем непривилегированного пользователя и добавляем его в группу. 
RUN addgroup -S -g 1000 user && adduser -S -u 1000 -D -G user user

# Изменяем владельца рабочей директории на пользователя "user" и группу "user".
RUN chown -R user:user /var/backend

# Переключаем контекст выполнения команд на "user". Все последующие команды будут выполняться от имени этого пользователя.
USER user

# Запускаем команду для сбора статических файлов Django.
RUN python manage.py collectstatic --no-input # --no-input предотвращает запросы ввода во время выполнения команды.

# Указываем, что контейнер будет использовать порт 8000.
EXPOSE 8000
```


### 3. docker-compose.yml
Для запуска приложения и базы данных был создан `docker-compose.yml`. Файл включает описание двух сервисов: backend и migrations.

### 4. Переменные окружения
Все конфигурации приложения вынесены в переменные окружения и передается через `docker-compose.yml`:
- `POSTGRES_SERVICE_HOST`: адрес базы данных (PostgreSQL).
- `POSTGRES_DB`: имя базы данных.
- `POSTGRES_USERNAME`: имя пользователя базы данных.
- `POSTGRES_PASSWORD`: пароль пользователя базы данных.
- `POSTGRES_SERVICE_PORT`: порт, на котором сервер слушает подключения.
- `DJANGO_SECRET_KEY`: ключ Django для обеспечения безопасности.

### 5. Непривилегированный пользователь
В контейнере создан непривилегированный пользователь `user`, от имени которого запускается приложение, что повышает безопасность.

### 6. Удаление кэша
Очистка кэша происходит в команде pip install --no-cache-dir -r requirements.txt. Флаг --no-cache-dir предотвращает сохранение кэша установленных пакетов, что уменьшает размер образа.

## Вывод
В результате выполнения лабораторной работы мы научились контейнеризировать приложение, выполнив все требуемые условия.
